#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from http.server import BaseHTTPRequestHandler, HTTPServer
import os
import socket
import socketserver
import argparse
from time import sleep
from lib_sonos import utils

if os.name != "nt":
    import fcntl
    import struct

from lib_sonos.sonos_commands import Command
from lib_sonos.sonos_service import SonosServerService


def get_interface_ip(ifname):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', ifname[:15].encode('utf-8')))[20:24])


def get_lan_ip():
    ip = socket.gethostbyname(socket.gethostname())
    if ip.startswith("127.") and os.name != "nt":
        interfaces = ["eth0", "eth1", "eth2", "wlan0", "wlan1", "wifi0", "ath0", "ath1", "ppp0"]
        for ifname in interfaces:
            try:
                ip = get_interface_ip(ifname)
                break;
            except IOError:
                pass
    return ip


class SonosHttpHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            result, response = command.do_work(self.client_address[0], self.path)

            status = 'Error'
            if result:
                self.send_response(200, 'OK')
                status = 'Success'
            else:
                self.send_response(400, 'Bad request')

            self.send_header("Content-type", "text/html")
            self.end_headers()
            self.wfile.write("<html><head><title>{}</title></head>".format(status).encode('utf-8'))
            self.wfile.write("<body><p>{}</p></body>".format(response).encode('utf-8'))
        finally:
            self.connection.close()

    def do_NOTIFY(self):
        try:
            self.send_response(200, "OK")

            #get subscription id and find the connected speaker uid
            sid = self.headers['SID']
            content_len = int(self.headers['content-length'])
            post_body = self.rfile.read(content_len).decode('utf-8')
            print(post_body)
            sonos_service.response_parser(sid, post_body)
        finally:
            self.connection.close


class ThreadedHTTPServer(socketserver.ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""


parser = argparse.ArgumentParser()
parser.add_argument('--port', help='Http server port', type=int, dest='port', default=12900)
parser.add_argument('--host', help='Http server host', dest='host', default='0.0.0.0')
parser.add_argument('--localip',
                    help='IP of this server in the local network. By default, sonos_broker tries to fetch the ip automatically.',
                    dest='localip')
parser.add_argument('--disable_tts', action='store_true', help='Disable Google Text-To-Speech', default=False,
                    dest='disable_tts')
parser.add_argument('--smb_url',
                    help='Url of samba share to store Google Text-to-Speech files. Leave it empty to fetch it by the fstab entry (insert a comment-line with #sonos before your mount command).',

                    dest='smb_url')
parser.add_argument('--local_share',
                    help='Local mounted samba share pointed to smb_url. Leave it empty to fetch it by the fstab entry (insert a comment-line with #sonos before your mount command). '
                         'A mounted smb share with read/write permissions is required.',
                    dest='local_share')
parser.add_argument('--quota',
                    help='Max. disk quota to store tts files in megabytes.', dest='quota', default=100, type=int)

args = parser.parse_args()
port = args.port
host = args.host
disable_tts = args.disable_tts
smb_url = args.smb_url
local_share = args.local_share
quota = args.quota

valid_tts = True

if not disable_tts:
    s, l = utils.parse_fstab()

    if not smb_url:
        if not s:
            print('No smb url given!')
            valid_tts = False
        else:
            smb_url = s

    if not local_share:
        if not l:
            print('No local share given!')
            valid_tts = False
        else:
            local_share = l

    if not utils.check_directory_permissions(local_share):
        print('No sufficient folder permissions in \'{}\'!'.format(local_share))
        valid_tts = False
    else:
        free_diskspace = utils.get_free_space_mb(local_share)
        print('Free diskspace: {} mb'.format(free_diskspace))

        if free_diskspace < quota:
            print('Not enough diskspace left on \'{}\'. At least {} mb of free diskspace required!'.format(local_share, quota))
            valid_tts = False


if disable_tts or not valid_tts:
    print('Google-TTS disabled!')
else:
    print('Google-TTS enabled!')
    print('smb url:\t\t{}'.format(smb_url))
    print('local share:\t\t{}'.format(local_share))

if args.localip:
    local_ip = args.localip
else:
    local_ip = get_lan_ip()

print("Starting server with ip address %s ... be sure this is correct." % local_ip)
sleep(2)

sonos_service = SonosServerService(local_ip, port, smb_url, local_share, quota, disable_tts)
command = Command(sonos_service)

if __name__ == "__main__":
    http_server = ThreadedHTTPServer((host, port), SonosHttpHandler)
    print('Starting http server, use <Ctrl-C> to stop')
    http_server.serve_forever()