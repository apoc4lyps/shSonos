#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from http.server import BaseHTTPRequestHandler, HTTPServer
import os
import socket
import socketserver
import argparse
from time import sleep
import configparser
from lib_sonos import utils
from lib_sonos import definitions

if os.name != "nt":
    import fcntl
    import struct

from lib_sonos.sonos_commands import Command
from lib_sonos.sonos_service import SonosServerService


def get_interface_ip(ifname):
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    return socket.inet_ntoa(fcntl.ioctl(s.fileno(), 0x8915, struct.pack('256s', ifname[:15].encode('utf-8')))[20:24])


def get_lan_ip():
    ip = socket.gethostbyname(socket.gethostname())
    if ip.startswith("127.") and os.name != "nt":
        interfaces = ["eth0", "eth1", "eth2", "wlan0", "wlan1", "wifi0", "ath0", "ath1", "ppp0"]
        for ifname in interfaces:
            try:
                ip = get_interface_ip(ifname)
                break;
            except IOError:
                pass
    return ip


class SonosHttpHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        try:
            result, response = command.do_work(self.client_address[0], self.path)

            status = 'Error'
            if result:
                self.send_response(definitions.HTTP_SUCCESS, 'OK')
                status = 'Success'
            else:
                self.send_response(definitions.HTTP_ERROR, 'Bad request')

            self.send_header("Content-type", "text/html")
            self.end_headers()
            #self.wfile.write("<html><head><title>{}</title></head>".format(status).encode('utf-8'))
            #self.wfile.write("<body><p>{}</p></body>".format(response).encode('utf-8'))
            self.wfile.write("{}".format(response).encode('utf-8'))
        finally:
            self.connection.close()

    def do_NOTIFY(self):
        try:
            self.send_response(definitions.HTTP_SUCCESS, "OK")
            #get subscription id and find the connected speaker uid
            sid = self.headers['SID']
            content_len = int(self.headers['content-length'])
            post_body = self.rfile.read(content_len).decode('utf-8')
            sonos_service.response_parser(sid, post_body)
        finally:
            self.connection.close


class ThreadedHTTPServer(socketserver.ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""

config = configparser.ConfigParser()
config.read(definitions.DEFAULT_CFG)

server_ip = None
port = definitions.DEFAULT_PORT
host = definitions.DEFAULT_HOST

if config.has_section('sonos_broker'):
    if config.has_option('sonos_broker', 'server_ip'):
        server_ip = config.get('sonos_broker', 'server_ip')

    if config.has_option('sonos_broker', 'host'):
        host = config.get('sonos_broker', 'host')

    if config.has_option('sonos_broker', 'port'):
        port = config.getint('sonos_broker', 'port')

if not server_ip:
    server_ip = get_lan_ip()
    if not server_ip:
        raise ('Couldn\'t detect the internal server ip automatically! Set the ip address manually (see config file).')


tts_enabled = False
save_path = None
server_url = None
quota = None

if config.has_section('google_tts'):
    if config.has_option('google_tts', 'enabled'):
        tts_enabled = config.getboolean('google_tts', 'enabled')

    if tts_enabled:
        if config.has_option('google_tts', 'save_path'):
            save_path = config.get('google_tts', 'save_path')

        if config.has_option('google_tts', 'server_url'):
            server_url = config.get('google_tts', 'server_url')

        if config.has_option('google_tts', 'quota'):
            quota = config.getint('google_tts', 'quota')

if tts_enabled and not save_path:
    print('No local save path given!')
    tts_enabled = False

if tts_enabled and not server_url:
    print('No local server url given!')
    tts_enabled = False

if tts_enabled and not quota:
    quota = definitions.DEFAULT_QUOTA

if tts_enabled:
    if not utils.check_directory_permissions(save_path):
        print('No sufficient folder permissions in \'{}\'!'.format(save_path))
        tts_enabled = False
    else:
        free_diskspace = utils.get_free_space_mb(save_path)
        print('Free diskspace: {} mb'.format(free_diskspace))

        if free_diskspace < quota:
            print('Not enough diskspace left on \'{}\'. At least {} mb of free diskspace required!'.format(save_path, quota))
            tts_enabled = False

if not tts_enabled:
    print('Google-TTS disabled!')
else:
    print('Google-TTS enabled!')
    print('server_url:\t\t{}'.format(server_url))
    print('save_path:\t\t{}'.format(save_path))


print("Starting server with ip address %s ... be sure this is correct." % server_ip)
sleep(1)

sonos_service = SonosServerService(server_ip, port, server_url, save_path, quota, tts_enabled)
command = Command(sonos_service)

if __name__ == "__main__":
    http_server = ThreadedHTTPServer((host, port), SonosHttpHandler)
    print('Starting http server, use <Ctrl-C> to stop')
    http_server.serve_forever()